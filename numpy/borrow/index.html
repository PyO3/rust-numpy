<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Types to safely create references into NumPy arrays"><title>numpy::borrow - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="numpy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../numpy/index.html">numpy</a><span class="version">0.22.0</span></h2></div><h2 class="location"><a href="#">Module borrow</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In crate numpy</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">numpy</a>::<wbr><a class="mod" href="#">borrow</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/numpy/borrow/mod.rs.html#1-691">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Types to safely create references into NumPy arrays</p>
<p>It is assumed that unchecked code - which includes unsafe Rust and Python - is validated by its author
which together with the dynamic borrow checking performed by this crate ensures that
safe Rust code cannot cause undefined behaviour by creating references into NumPy arrays.</p>
<p>With these borrows established, <a href="struct.PyReadonlyArray.html#method.get" title="method numpy::borrow::PyReadonlyArray::get">references to individual elements</a> or <a href="struct.PyReadonlyArray.html#method.as_array" title="method numpy::borrow::PyReadonlyArray::as_array">reference-based views of whole array</a>
can be created safely. These are then the starting point for algorithms iteraing over and operating on the elements of the array.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>The first example shows that dynamic borrow checking works to constrain
both what safe Rust code can invoke and how it is invoked.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>numpy::{PyArray1, PyArrayMethods};
<span class="kw">use </span>ndarray::Zip;
<span class="kw">use </span>pyo3::{Python, Bound};

<span class="kw">fn </span>add(x: <span class="kw-2">&amp;</span>Bound&lt;<span class="lifetime">'_</span>, PyArray1&lt;f64&gt;&gt;, y: <span class="kw-2">&amp;</span>Bound&lt;<span class="lifetime">'_</span>, PyArray1&lt;f64&gt;&gt;, z: <span class="kw-2">&amp;</span>Bound&lt;<span class="lifetime">'_</span>, PyArray1&lt;f64&gt;&gt;) {
    <span class="kw">let </span>x1 = x.readonly();
    <span class="kw">let </span>y1 = y.readonly();
    <span class="kw">let </span><span class="kw-2">mut </span>z1 = z.readwrite();

    <span class="kw">let </span>x2 = x1.as_array();
    <span class="kw">let </span>y2 = y1.as_array();
    <span class="kw">let </span>z2 = z1.as_array_mut();

    Zip::from(x2)
        .and(y2)
        .and(z2)
        .for_each(|x3, y3, z3| <span class="kw-2">*</span>z3 = x3 + y3);

    <span class="comment">// Will fail at runtime due to conflict with `x1`.
    </span><span class="kw">let </span>res = catch_unwind(AssertUnwindSafe(|| {
        <span class="kw">let </span>_x4 = x.readwrite();
    }));
    <span class="macro">assert!</span>(res.is_err());
}

Python::with_gil(|py| {
    <span class="kw">let </span>x = PyArray1::&lt;f64&gt;::zeros_bound(py, <span class="number">42</span>, <span class="bool-val">false</span>);
    <span class="kw">let </span>y = PyArray1::&lt;f64&gt;::zeros_bound(py, <span class="number">42</span>, <span class="bool-val">false</span>);
    <span class="kw">let </span>z = PyArray1::&lt;f64&gt;::zeros_bound(py, <span class="number">42</span>, <span class="bool-val">false</span>);

    <span class="comment">// Will work as the three arrays are distinct.
    </span>add(<span class="kw-2">&amp;</span>x, <span class="kw-2">&amp;</span>y, <span class="kw-2">&amp;</span>z);

    <span class="comment">// Will work as `x1` and `y1` are compatible borrows.
    </span>add(<span class="kw-2">&amp;</span>x, <span class="kw-2">&amp;</span>x, <span class="kw-2">&amp;</span>z);

    <span class="comment">// Will fail at runtime due to conflict between `y1` and `z1`.
    </span><span class="kw">let </span>res = catch_unwind(AssertUnwindSafe(|| {
        add(<span class="kw-2">&amp;</span>x, <span class="kw-2">&amp;</span>y, <span class="kw-2">&amp;</span>y);
    }));
    <span class="macro">assert!</span>(res.is_err());
});</code></pre></div>
<p>The second example shows that non-overlapping and interleaved views are also supported.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>numpy::{PyArray1, PyArrayMethods};
<span class="kw">use </span>pyo3::{types::{IntoPyDict, PyAnyMethods}, Python};

Python::with_gil(|py| {
    <span class="kw">let </span>array = PyArray1::arange_bound(py, <span class="number">0.0</span>, <span class="number">10.0</span>, <span class="number">1.0</span>);
    <span class="kw">let </span>locals = [(<span class="string">"array"</span>, array)].into_py_dict_bound(py);

    <span class="kw">let </span>view1 = py.eval_bound(<span class="string">"array[:5]"</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>locals)).unwrap().downcast_into::&lt;PyArray1&lt;f64&gt;&gt;().unwrap();
    <span class="kw">let </span>view2 = py.eval_bound(<span class="string">"array[5:]"</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>locals)).unwrap().downcast_into::&lt;PyArray1&lt;f64&gt;&gt;().unwrap();
    <span class="kw">let </span>view3 = py.eval_bound(<span class="string">"array[::2]"</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>locals)).unwrap().downcast_into::&lt;PyArray1&lt;f64&gt;&gt;().unwrap();
    <span class="kw">let </span>view4 = py.eval_bound(<span class="string">"array[1::2]"</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>locals)).unwrap().downcast_into::&lt;PyArray1&lt;f64&gt;&gt;().unwrap();

    {
        <span class="kw">let </span>_view1 = view1.readwrite();
        <span class="kw">let </span>_view2 = view2.readwrite();
    }

    {
        <span class="kw">let </span>_view3 = view3.readwrite();
        <span class="kw">let </span>_view4 = view4.readwrite();
    }
});</code></pre></div>
<p>The third example shows that some views are incorrectly rejected since the borrows are over-approximated.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>numpy::{PyArray2, PyArrayMethods};
<span class="kw">use </span>pyo3::{types::{IntoPyDict, PyAnyMethods}, Python};

Python::with_gil(|py| {
    <span class="kw">let </span>array = PyArray2::&lt;f64&gt;::zeros_bound(py, (<span class="number">10</span>, <span class="number">10</span>), <span class="bool-val">false</span>);
    <span class="kw">let </span>locals = [(<span class="string">"array"</span>, array)].into_py_dict_bound(py);

    <span class="kw">let </span>view1 = py.eval_bound(<span class="string">"array[:, ::3]"</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>locals)).unwrap().downcast_into::&lt;PyArray2&lt;f64&gt;&gt;().unwrap();
    <span class="kw">let </span>view2 = py.eval_bound(<span class="string">"array[:, 1::3]"</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>locals)).unwrap().downcast_into::&lt;PyArray2&lt;f64&gt;&gt;().unwrap();

    <span class="comment">// A false conflict as the views do not actually share any elements.
    </span><span class="kw">let </span>res = catch_unwind(AssertUnwindSafe(|| {
        <span class="kw">let </span>_view1 = view1.readwrite();
        <span class="kw">let </span>_view2 = view2.readwrite();
    }));
    <span class="macro">assert!</span>(res.is_err());
});</code></pre></div>
<h2 id="rationale"><a class="doc-anchor" href="#rationale">§</a>Rationale</h2>
<p>Rust references require aliasing discipline to be maintained, i.e. there must always
exist only a single mutable (aka exclusive) reference or multiple immutable (aka shared) references
for each object, otherwise the program contains undefined behaviour.</p>
<p>The aim of this module is to ensure that safe Rust code is unable to violate these requirements on its own.
We cannot prevent unchecked code - this includes unsafe Rust, Python or other native code like C or Fortran -
from violating them. Therefore the responsibility to avoid this lies with the author of that code instead of the compiler.
However, assuming that the unchecked code is correct, we can ensure that safe Rust is unable to introduce mistakes
into an otherwise correct program by dynamically checking which arrays are currently borrowed and in what manner.</p>
<p>This means that we follow the <a href="https://numpy.org/doc/stable/reference/c-api/types-and-structures.html#c.NPY_AO.base">base object chain</a> of each array to the original allocation backing it and
track which parts of that allocation are covered by the array and thereby ensure that only a single read-write array
or multiple read-only arrays overlapping with that region are borrowed at any time.</p>
<p>In contrast to Rust references, the mere existence of Python references or raw pointers is not an issue
because these values are not assumed to follow aliasing discipline by the Rust compiler.</p>
<p>This cannot prevent unchecked code from concurrently modifying an array via callbacks or using multiple threads,
but that would lead to incorrect results even if the code that is interfered with is implemented in another language
which does not require aliasing discipline.</p>
<p>Concerning multi-threading in particular: While the GIL needs to be acquired to create borrows, they are not bound to the GIL
and will stay active after the GIL is released, for example by calling [<code>allow_threads</code>][pyo3::Python::allow_threads].
Borrows also do not provide synchronization, i.e. multiple threads borrowing the same array will lead to runtime panics,
it will not block those threads until already active borrows are released.</p>
<p>In summary, this crate takes the position that all unchecked code - unsafe Rust, Python, C, Fortran, etc. - must be checked for correctness by its author.
Safe Rust code can then rely on this correctness, but should not be able to introduce memory safety issues on its own. Additionally, dynamic borrow checking
can catch <em>some</em> mistakes introduced by unchecked code, e.g. Python calling a function with the same array as an input and as an output argument.</p>
<h2 id="limitations"><a class="doc-anchor" href="#limitations">§</a>Limitations</h2>
<p>Note that the current implementation of this is an over-approximation: It will consider borrows
potentially conflicting if the initial arrays have the same object at the end of their <a href="https://numpy.org/doc/stable/reference/c-api/types-and-structures.html#c.NPY_AO.base">base object chain</a>.
Then, multiple conditions which are sufficient but not necessary to show the absence of conflicts are checked.</p>
<p>While this is sufficient to handle common situations like slicing an array with a non-unit step size which divides
the dimension along that axis, there are also cases which it does not handle. For example, if the step size does
not divide the dimension along the sliced axis. Under such conditions, borrows are rejected even though the arrays
do not actually share any elements.</p>
<p>This does limit the set of programs that can be written using safe Rust in way similar to rustc itself
which ensures that all accepted programs are memory safe but does not necessarily accept all memory safe programs.
However, the unsafe method <a href="../array/struct.PyArray.html#method.as_array_mut" title="method numpy::array::PyArray::as_array_mut"><code>PyArray::as_array_mut</code></a> can be used as an escape hatch.
More involved cases like the example from above may be supported in the future.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.PyReadonlyArray.html" title="struct numpy::borrow::PyReadonlyArray">PyReadonlyArray</a></div><div class="desc docblock-short">Read-only borrow of an array.</div></li><li><div class="item-name"><a class="struct" href="struct.PyReadwriteArray.html" title="struct numpy::borrow::PyReadwriteArray">PyReadwriteArray</a></div><div class="desc docblock-short">Read-write borrow of an array.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.PyReadonlyArray0.html" title="type numpy::borrow::PyReadonlyArray0">PyReadonlyArray0</a></div><div class="desc docblock-short">Read-only borrow of a zero-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadonlyArray1.html" title="type numpy::borrow::PyReadonlyArray1">PyReadonlyArray1</a></div><div class="desc docblock-short">Read-only borrow of a one-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadonlyArray2.html" title="type numpy::borrow::PyReadonlyArray2">PyReadonlyArray2</a></div><div class="desc docblock-short">Read-only borrow of a two-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadonlyArray3.html" title="type numpy::borrow::PyReadonlyArray3">PyReadonlyArray3</a></div><div class="desc docblock-short">Read-only borrow of a three-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadonlyArray4.html" title="type numpy::borrow::PyReadonlyArray4">PyReadonlyArray4</a></div><div class="desc docblock-short">Read-only borrow of a four-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadonlyArray5.html" title="type numpy::borrow::PyReadonlyArray5">PyReadonlyArray5</a></div><div class="desc docblock-short">Read-only borrow of a five-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadonlyArray6.html" title="type numpy::borrow::PyReadonlyArray6">PyReadonlyArray6</a></div><div class="desc docblock-short">Read-only borrow of a six-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadonlyArrayDyn.html" title="type numpy::borrow::PyReadonlyArrayDyn">PyReadonlyArrayDyn</a></div><div class="desc docblock-short">Read-only borrow of an array whose dimensionality is determined at runtime.</div></li><li><div class="item-name"><a class="type" href="type.PyReadwriteArray0.html" title="type numpy::borrow::PyReadwriteArray0">PyReadwriteArray0</a></div><div class="desc docblock-short">Read-write borrow of a zero-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadwriteArray1.html" title="type numpy::borrow::PyReadwriteArray1">PyReadwriteArray1</a></div><div class="desc docblock-short">Read-write borrow of a one-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadwriteArray2.html" title="type numpy::borrow::PyReadwriteArray2">PyReadwriteArray2</a></div><div class="desc docblock-short">Read-write borrow of a two-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadwriteArray3.html" title="type numpy::borrow::PyReadwriteArray3">PyReadwriteArray3</a></div><div class="desc docblock-short">Read-write borrow of a three-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadwriteArray4.html" title="type numpy::borrow::PyReadwriteArray4">PyReadwriteArray4</a></div><div class="desc docblock-short">Read-write borrow of a four-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadwriteArray5.html" title="type numpy::borrow::PyReadwriteArray5">PyReadwriteArray5</a></div><div class="desc docblock-short">Read-write borrow of a five-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadwriteArray6.html" title="type numpy::borrow::PyReadwriteArray6">PyReadwriteArray6</a></div><div class="desc docblock-short">Read-write borrow of a six-dimensional array.</div></li><li><div class="item-name"><a class="type" href="type.PyReadwriteArrayDyn.html" title="type numpy::borrow::PyReadwriteArrayDyn">PyReadwriteArrayDyn</a></div><div class="desc docblock-short">Read-write borrow of an array whose dimensionality is determined at runtime.</div></li></ul></section></div></main></body></html>